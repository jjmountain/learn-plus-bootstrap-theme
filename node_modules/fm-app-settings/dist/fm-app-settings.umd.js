(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('js-cookie'), require('bootstrap-vue/es/mixins/id'), require('bootstrap-vue/es/mixins/form-options'), require('bootstrap-vue/es/mixins/form'), require('dom-factory'), require('material-design-kit/dist/drawer.js'), require('perfect-scrollbar'), require('camelcase-keys'), require('bootstrap-vue/es/utils/target'), require('bootstrap-vue/es/utils/dom')) :
  typeof define === 'function' && define.amd ? define(['exports', 'js-cookie', 'bootstrap-vue/es/mixins/id', 'bootstrap-vue/es/mixins/form-options', 'bootstrap-vue/es/mixins/form', 'dom-factory', 'material-design-kit/dist/drawer.js', 'perfect-scrollbar', 'camelcase-keys', 'bootstrap-vue/es/utils/target', 'bootstrap-vue/es/utils/dom'], factory) :
  (factory((global.fmAppSettings = {}),global.Cookie,global.idMixin,global.formOptionsMixin,global.formMixin,global.domFactory,null,global.PerfectScrollbar,global.camelCaseKeys,global.target,global.dom));
}(this, (function (exports,Cookie,idMixin,formOptionsMixin,formMixin,domFactory,drawer_js,PerfectScrollbar,camelCaseKeys,target,dom) { 'use strict';

  Cookie = Cookie && Cookie.hasOwnProperty('default') ? Cookie['default'] : Cookie;
  idMixin = idMixin && idMixin.hasOwnProperty('default') ? idMixin['default'] : idMixin;
  formOptionsMixin = formOptionsMixin && formOptionsMixin.hasOwnProperty('default') ? formOptionsMixin['default'] : formOptionsMixin;
  formMixin = formMixin && formMixin.hasOwnProperty('default') ? formMixin['default'] : formMixin;
  PerfectScrollbar = PerfectScrollbar && PerfectScrollbar.hasOwnProperty('default') ? PerfectScrollbar['default'] : PerfectScrollbar;
  camelCaseKeys = camelCaseKeys && camelCaseKeys.hasOwnProperty('default') ? camelCaseKeys['default'] : camelCaseKeys;
  target = target && target.hasOwnProperty('default') ? target['default'] : target;

  function decode(s) {
    return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent)
  }

  function getCookie(key, json, req) {
    if ( req === void 0 ) req = document;

    if (typeof req === 'undefined') {
      return
    }

    var jar = {};
    // To prevent the for loop in the first place assign an empty array
    // in case there are no cookies at all.
    var cookies = req.cookie ? req.cookie.split('; ') : [];
    var i = 0;

    for (; i < cookies.length; i++) {
      var parts = cookies[i].split('=');
      var cookie = parts.slice(1).join('=');

      if (!json && cookie.charAt(0) === '"') {
        cookie = cookie.slice(1, -1);
      }

      try {
        var name = decode(parts[0]);
        cookie = decode(cookie);

        if (json) {
          try {
            cookie = JSON.parse(cookie);
          } catch (e) {}
        }

        jar[name] = cookie;

        if (key === name) {
          break
        }
      } catch (e) {}
    }

    return key ? jar[key] : jar
  }

  var NAMESPACE = 'fm-app-settings';

  var ID = function () { return ("_" + (Math.random().toString(36).substr(2, 9))); };

  var Session = function Session(namespace) {
    this.namespace = namespace;
  };

  var prototypeAccessors = { namespace: { configurable: true } };

  Session.prototype.defaultNamespace = function defaultNamespace () {
    // session based unique namespace
    var namespace = Cookie.get((NAMESPACE + ".namespace"));
    if (!namespace) {
      namespace = ID();
    }
    return namespace
  };

  prototypeAccessors.namespace.get = function () {
    return this._namespace
  };

  prototypeAccessors.namespace.set = function (namespace) {
    if (!namespace) {
      namespace = this.defaultNamespace();
    }
    this._namespace = namespace;
    Cookie.set((NAMESPACE + ".namespace"), namespace);
  };

  Session.prototype.getMemoryKey = function getMemoryKey (key) {
    return (NAMESPACE + "." + (this.namespace) + "." + key)
  };

  Session.prototype.save = function save (key, value) {
    Cookie.set(this.getMemoryKey(key), value);
  };

  Session.prototype.memory = function memory (key) {
    return Cookie.getJSON(this.getMemoryKey(key))
  };

  Session.prototype.forget = function forget (key) {
    Cookie.remove(this.getMemoryKey(key));
  };

  Session.prototype.getSettingsFromRequest = function getSettingsFromRequest (req) {
    var settings = getCookie(this.getMemoryKey('settings'), true, req.headers);
    if (settings) {
      return settings
    }
  };

  Object.defineProperties( Session.prototype, prototypeAccessors );

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  var script = {
    props: {
      id: {
        type: String,
        required: true
      },
      title: {
        type: String,
        required: true
      }
    },
    methods: {
      emit: function emit(event) {
        this.$emit(event, this.collapseId);
      }
    },
    computed: {
      collapseId: function collapseId() {
        return ("settings-" + (this.id))
      }
    }
  };

  /* script */
              var __vue_script__ = script;
              
  /* template */
  var __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('b-card',{staticClass:"mb-1",attrs:{"no-body":""}},[_c('b-card-header',{directives:[{name:"b-toggle",rawName:"v-b-toggle",value:(_vm.collapseId),expression:"collapseId"}],attrs:{"role":"tab"}},[_c('h5',{staticClass:"card-title",domProps:{"textContent":_vm._s(_vm.title)}})]),_vm._v(" "),_c('b-collapse',{attrs:{"id":_vm.collapseId,"visible":"","accordion":"settings","role":"tabpanel"},on:{"show":function($event){_vm.emit('show');},"shown":function($event){_vm.emit('shown');},"hide":function($event){_vm.emit('hide');},"hidden":function($event){_vm.emit('hidden');}}},[_c('b-card-body',[_vm._t("default")],2)],1)],1)};
  var __vue_staticRenderFns__ = [];

    /* style */
    var __vue_inject_styles__ = undefined;
    /* scoped */
    var __vue_scope_id__ = undefined;
    /* module identifier */
    var __vue_module_identifier__ = undefined;
    /* functional template */
    var __vue_is_functional_template__ = false;
    /* component normalizer */
    function __vue_normalize__(
      template, style, script$$1,
      scope, functional, moduleIdentifier,
      createInjector, createInjectorSSR
    ) {
      var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {};

      // For security concerns, we use only base name in production mode.
      component.__file = "Collapse.vue";

      if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) { component.functional = true; }
      }

      component._scopeId = scope;

      return component
    }
    /* style inject */
    
    /* style inject SSR */
    

    
    var Collapse = __vue_normalize__(
      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
      __vue_inject_styles__,
      __vue_script__,
      __vue_scope_id__,
      __vue_is_functional_template__,
      __vue_module_identifier__,
      undefined,
      undefined
    );

  //

  var script$1 = {
    mixins: [idMixin, formMixin, formOptionsMixin],
    model: {
      prop: 'checked',
      event: 'input'
    },
    props: {
      checked: {
        type: [String, Object, Number, Boolean],
        default: null
      },
      validated: {
        // Used for applying the `was-validated` class to the group
        type: Boolean,
        default: false
      },
      ariaInvalid: {
        type: [Boolean, String],
        default: false
      }
    },
    data: function data() {
      return {
        localChecked: this.checked,
        // Flag for children
        is_RadioCheckGroup: true,
        plain: true
      }
    },
    computed: {
      groupClasses: function groupClasses() {
        return [this.validated ? 'was-validated' : '']
      },
      computedAriaInvalid: function computedAriaInvalid() {
        if (
          this.ariaInvalid === true ||
          this.ariaInvalid === 'true' ||
          this.ariaInvalid === ''
        ) {
          return 'true'
        }
        return this.get_State === false ? 'true' : null
      },
      get_State: function get_State() {
        // Required by child radios
        return this.computedState
      }
    },
    watch: {
      checked: function checked(newVal, oldVal) {
        this.localChecked = this.checked;
      },
      localChecked: function localChecked(newVal, oldVal) {
        this.$emit('input', newVal);
      }
    }
  };

  /* script */
              var __vue_script__$1 = script$1;
              
  /* template */
  var __vue_render__$1 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"row no-gutters flex-nowrap form-image-group",class:_vm.groupClasses,attrs:{"aria-required":_vm.required,"aria-invalid":_vm.computedAriaInvalid,"role":"radiogroup","tabindex":"-1"}},_vm._l((_vm.options),function(item,idx){return _c('div',{key:(_vm.name + "-" + (item.value)),staticClass:"col",class:{ 'ml-2': idx > 0 }},[_c('b-form-radio',{attrs:{"id":(_vm.name + "-" + (item.value)),"value":item.value,"disabled":item.disabled,"required":Boolean(_vm.name && _vm.required),"name":_vm.name}},[_c('b-img',{attrs:{"src":item.image,"alt":item.text,"fluid":""}})],1)],1)}),0)};
  var __vue_staticRenderFns__$1 = [];

    /* style */
    var __vue_inject_styles__$1 = function (inject) {
      if (!inject) { return }
      inject("data-v-a6669546_0", { source: ".form-image-group{position:relative}.form-image-group .form-check{margin:0}.form-image-group .form-check-inline .form-check-input{position:absolute;z-index:-1;opacity:0}.form-image-group label{cursor:pointer;margin:0;padding:4px;border:1px solid #f0f1f2;border-radius:.25rem}.form-image-group :checked~label{padding:2px;border:3px solid #2196f3}.is-valid .form-image-group :checked~label{border-color:#66bb6a}.is-invalid .form-image-group label{border-color:#f44336}", map: undefined, media: undefined });

    };
    /* scoped */
    var __vue_scope_id__$1 = undefined;
    /* module identifier */
    var __vue_module_identifier__$1 = undefined;
    /* functional template */
    var __vue_is_functional_template__$1 = false;
    /* component normalizer */
    function __vue_normalize__$1(
      template, style, script,
      scope, functional, moduleIdentifier,
      createInjector, createInjectorSSR
    ) {
      var component = (typeof script === 'function' ? script.options : script) || {};

      // For security concerns, we use only base name in production mode.
      component.__file = "FormImageGroup.vue";

      if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) { component.functional = true; }
      }

      component._scopeId = scope;

      {
        var hook;
        if (style) {
          hook = function(context) {
            style.call(this, createInjector(context));
          };
        }

        if (hook !== undefined) {
          if (component.functional) {
            // register for functional component in vue file
            var originalRender = component.render;
            component.render = function renderWithStyleInjection(h, context) {
              hook.call(context);
              return originalRender(h, context)
            };
          } else {
            // inject component registration as beforeCreate hook
            var existing = component.beforeCreate;
            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
        }
      }

      return component
    }
    /* style inject */
    function __vue_create_injector__() {
      var head = document.head || document.getElementsByTagName('head')[0];
      var styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});
      var isOldIE =
        typeof navigator !== 'undefined' &&
        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

      return function addStyle(id, css) {
        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

        var group = isOldIE ? css.media || 'default' : id;
        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

        if (!style.ids.includes(id)) {
          var code = css.source;
          var index = style.ids.length;

          style.ids.push(id);

          if (css.map) {
            // https://developer.chrome.com/devtools/docs/javascript-debugging
            // this makes source maps inside style tags work properly in Chrome
            code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
            // http://stackoverflow.com/a/26603875
            code +=
              '\n/*# sourceMappingURL=data:application/json;base64,' +
              btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
              ' */';
          }

          if (isOldIE) {
            style.element = style.element || document.querySelector('style[data-group=' + group + ']');
          }

          if (!style.element) {
            var el = style.element = document.createElement('style');
            el.type = 'text/css';

            if (css.media) { el.setAttribute('media', css.media); }
            if (isOldIE) {
              el.setAttribute('data-group', group);
              el.setAttribute('data-next-index', '0');
            }

            head.appendChild(el);
          }

          if (isOldIE) {
            index = parseInt(style.element.getAttribute('data-next-index'));
            style.element.setAttribute('data-next-index', index + 1);
          }

          if (style.element.styleSheet) {
            style.parts.push(code);
            style.element.styleSheet.cssText = style.parts
              .filter(Boolean)
              .join('\n');
          } else {
            var textNode = document.createTextNode(code);
            var nodes = style.element.childNodes;
            if (nodes[index]) { style.element.removeChild(nodes[index]); }
            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
            else { style.element.appendChild(textNode); }
          }
        }
      }
    }
    /* style inject SSR */
    

    
    var FormImageGroup = __vue_normalize__$1(
      { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
      __vue_inject_styles__$1,
      __vue_script__$1,
      __vue_scope_id__$1,
      __vue_is_functional_template__$1,
      __vue_module_identifier__$1,
      __vue_create_injector__,
      undefined
    );

  var script$2 = {
    components: {
      Collapse: Collapse,
      FormImageGroup: FormImageGroup
    },
    data: function data() {
      return {
        session: null,
        settings: {},
      }
    },
    props: {
      namespace: {
        type: String,
        default: null
      },
      options: {
        type: Array,
        required: true
      },
      debug: {
        type: Boolean,
        default: false
      }
    },
    watch: {
      settings: {
        deep: true,
        handler: function handler(value) {
          this.setSettings();
        }
      }
    },
    created: function created() {
      this.session = new Session(this.namespace);
      this.initSettings();
    },
    methods: {
      initSettings: function initSettings() {
        var this$1 = this;

        var memory = this.session.memory('settings');

        this.options.forEach(function (option) {
          option.children.forEach(function (group) {
            if (this$1.settings[((option.id) + "." + (group.id))] === undefined) {
              var value;

              if (group.cookies === undefined || group.cookies !== false) {
                try {
                  value = memory[((option.id) + "." + (group.id))];
                } catch(e) {}
              }
              
              var def = group.options.find(function (o) { return o.selected === true; });
              if (!value && def !== undefined) {
                value = def.value;
              }
              if (!value && value !== false) {
                value = group.options[0].value;
              }

              this$1.$set(this$1.settings, ((option.id) + "." + (group.id)), value);
            }
          });
        });
      },
      setSettings: function setSettings(reload) {
        this.session.save('settings', this.settings);

        this.$root.$emit('fm:settings:state', this.settings);

        if (reload) {
          location.reload();
        }
      }
    }
  };

  /* script */
              var __vue_script__$2 = script$2;
              
  /* template */

    /* style */
    var __vue_inject_styles__$2 = undefined;
    /* scoped */
    var __vue_scope_id__$2 = undefined;
    /* module identifier */
    var __vue_module_identifier__$2 = undefined;
    /* functional template */
    var __vue_is_functional_template__$2 = undefined;
    /* component normalizer */
    function __vue_normalize__$2(
      template, style, script,
      scope, functional, moduleIdentifier,
      createInjector, createInjectorSSR
    ) {
      var component = (typeof script === 'function' ? script.options : script) || {};

      // For security concerns, we use only base name in production mode.
      component.__file = "Settings.vue";

      if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) { component.functional = true; }
      }

      component._scopeId = scope;

      return component
    }
    /* style inject */
    
    /* style inject SSR */
    

    
    var Settings = __vue_normalize__$2(
      {},
      __vue_inject_styles__$2,
      __vue_script__$2,
      __vue_scope_id__$2,
      __vue_is_functional_template__$2,
      __vue_module_identifier__$2,
      undefined,
      undefined
    );

  if (!Array.isArray) {
    Array.isArray = function (arg) { return Object.prototype.toString.call(arg) === '[object Array]'; };
  }

  var isArray = Array.isArray;

  var BVRL = '__BV_root_listeners__';

  var listenOnRootMixin = {
    methods: {
      /**
       * Safely register event listeners on the root Vue node.
       * While Vue automatically removes listeners for individual components,
       * when a component registers a listener on root and is destroyed,
       * this orphans a callback because the node is gone,
       * but the root does not clear the callback.
       *
       * This adds a non-reactive prop to a vm on the fly
       * in order to avoid object observation and its performance costs
       * to something that needs no reactivity.
       * It should be highly unlikely there are any naming collisions.
       * @param {string} event
       * @param {function} callback
       * @chainable
       */
      listenOnRoot: function listenOnRoot(event, callback) {
        if (!this[BVRL] || !isArray(this[BVRL])) {
          this[BVRL] = [];
        }
        this[BVRL].push({ event: event, callback: callback });
        this.$root.$on(event, callback);
        return this
      },

      /**
       * Convenience method for calling vm.$emit on vm.$root.
       * @param {string} event
       * @param {*} args
       * @chainable
       */
      emitOnRoot: function emitOnRoot(event) {
        var ref;

        var args = [], len = arguments.length - 1;
        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
        (ref = this.$root).$emit.apply(ref, [ event ].concat( args ));
        return this
      }
    },

    beforeDestroy: function beforeDestroy() {
      if (this[BVRL] && isArray(this[BVRL])) {
        while (this[BVRL].length > 0) {
          // shift to process in order
          var ref = this[BVRL].shift();
          var event = ref.event;
          var callback = ref.callback;
          this.$root.$off(event, callback);
        }
      }
    }
  };

  var drawerProps = {
    id: {
      type: String,
      default: function () { return 'default-drawer'; }
    },
    align: {
      type: String,
      default: 'start',
      validator: function (val) { return ['start', 'end', 'left', 'right'].includes(val); }
    },
    persistent: {
      type: Boolean,
      default: false
    },
    opened: {
      type: Boolean,
      default: false
    }
  };

  //

  // Events we emit on $root
  var EVENT_STATE = 'fm::drawer::state';

  // Events we listen to on $root
  var EVENT_TOGGLE = 'fm::toggle::drawer';

  var script$3 = {
    mixins: [listenOnRootMixin],
    props: drawerProps,
    data: function data() {
      return {
        show: this.opened
      }
    },
    computed: {
      state: function state() {
        return {
          id: this.id,
          show: this.show,
          align: this.align,
          persistent: this.persistent
        }
      }
    },
    watch: {
      show: function show(newVal, oldVal) {
        var this$1 = this;

        if (newVal !== oldVal) {
          this.try(function () {
            this$1.$el.mdkDrawer[newVal ? 'open' : 'close']();
            this$1.emitState();
          });
        }
      },
      align: function align(newVal, oldVal) {
        var this$1 = this;

        if (newVal !== oldVal) {
          this.try(function () {
            this$1.$el.mdkDrawer.align = newVal;
            this$1.emitState();
          });
        }
      }
    },
    created: function created() {
      // Listen for toggle events to open/close us
      this.listenOnRoot(EVENT_TOGGLE, this.handleToggleEvt);
    },
    mounted: function mounted() {
      var this$1 = this;

      this.$el.addEventListener('mdk-drawer-change', function () { return this$1.onChangeHandler(); });
      this.$el.addEventListener('domfactory-component-upgraded', function () { return this$1.onInitHandler(); }
      );
      this.$nextTick(function () { return domFactory.handler.upgradeElement(this$1.$el, 'mdk-drawer'); });
    },
    beforeDestroy: function beforeDestroy() {
      var this$1 = this;

      domFactory.handler.downgradeElement(this.$el, 'mdk-drawer');
      this.$el.removeEventListener('mdk-drawer-change', function () { return this$1.onChangeHandler(); }
      );
      this.$el.removeEventListener('domfactory-component-upgraded', function () { return this$1.onInitHandler(); }
      );
    },
    methods: {
      onInitHandler: function onInitHandler() {
        if (this.opened) {
          this.open();
        }
      },
      onChangeHandler: function onChangeHandler() {
        if (this.$el.mdkDrawer) {
          this.show = this.$el.mdkDrawer.opened;
        }
      },
      try: function try$1(callback) {
        try {
          callback();
        } catch (e) {
          this.$el.addEventListener(
            'domfactory-component-upgraded',
            callback.bind(this)
          );
        }
      },
      toggle: function toggle() {
        this.show = !this.show;
      },
      open: function open() {
        this.show = true;
      },
      close: function close() {
        this.open = false;
      },
      emitState: function emitState() {
        this.$emit('input', this.show);
        // Let toggle know the state of this drawer
        this.$root.$emit(EVENT_STATE, this.id, this.state);
      },
      handleToggleEvt: function handleToggleEvt(target$$1) {
        if (target$$1 !== this.id) {
          return
        }
        this.toggle();
      }
    }
  };

  /* script */
              var __vue_script__$3 = script$3;
              
  /* template */
  var __vue_render__$2 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"mdk-drawer js-mdk-drawer",attrs:{"id":_vm.id,"data-align":_vm.align}},[_c('div',{staticClass:"mdk-drawer__content"},[_vm._t("default")],2)])};
  var __vue_staticRenderFns__$2 = [];

    /* style */
    var __vue_inject_styles__$3 = undefined;
    /* scoped */
    var __vue_scope_id__$3 = undefined;
    /* module identifier */
    var __vue_module_identifier__$3 = undefined;
    /* functional template */
    var __vue_is_functional_template__$3 = false;
    /* component normalizer */
    function __vue_normalize__$3(
      template, style, script,
      scope, functional, moduleIdentifier,
      createInjector, createInjectorSSR
    ) {
      var component = (typeof script === 'function' ? script.options : script) || {};

      // For security concerns, we use only base name in production mode.
      component.__file = "Drawer.vue";

      if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) { component.functional = true; }
      }

      component._scopeId = scope;

      return component
    }
    /* style inject */
    
    /* style inject SSR */
    

    
    var Drawer = __vue_normalize__$3(
      { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
      __vue_inject_styles__$3,
      __vue_script__$3,
      __vue_scope_id__$3,
      __vue_is_functional_template__$3,
      __vue_module_identifier__$3,
      undefined,
      undefined
    );

  //

  var script$4 = {
    props: {
      settings: {
        type: Object,
        default: function default$1() {
          return {
            wheelPropagation: false
          }
        }
      },
      tagname: {
        type: String,
        default: 'div'
      }
    },
    data: function data() {
      return {
        ps: null
      }
    },
    watch: {
      $route: function $route() {
        this.update();
      }
    },
    mounted: function mounted() {
      if (!this.$isServer) {
        this.__init();
      }
    },
    updated: function updated() {
      this.$nextTick(this.update);
    },
    activated: function activated() {
      this.__init();
    },
    deactivated: function deactivated() {
      this.__uninit();
    },
    beforeDestroy: function beforeDestroy() {
      this.__uninit();
    },
    methods: {
      scrollHandle: function scrollHandle(evt) {
        this.$emit(evt.type, evt);
      },
      update: function update() {
        this.ps.update();
      },
      __init: function __init() {
        if (!this.ps) {
          this.ps = new PerfectScrollbar(this.$el, this.settings);
        } else {
          this.update();
        }
      },
      __uninit: function __uninit() {
        this.ps.destroy();
        this.ps = null;
      }
    }
  };

  /* script */
              var __vue_script__$4 = script$4;
              
  /* template */
  var __vue_render__$3 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(_vm.$props.tagname,{tag:"div",staticClass:"ps-container",on:{"~mouseover":function($event){return _vm.update($event)},"ps-scroll-y":_vm.scrollHandle,"ps-scroll-x":_vm.scrollHandle,"ps-scroll-up":_vm.scrollHandle,"ps-scroll-down":_vm.scrollHandle,"ps-scroll-left":_vm.scrollHandle,"ps-scroll-right":_vm.scrollHandle,"ps-y-reach-start":_vm.scrollHandle,"ps-y-reach-end":_vm.scrollHandle,"ps-x-reach-start":_vm.scrollHandle,"ps-x-reach-end":_vm.scrollHandle}},[_vm._t("default")],2)};
  var __vue_staticRenderFns__$3 = [];

    /* style */
    var __vue_inject_styles__$4 = function (inject) {
      if (!inject) { return }
      inject("data-v-53fc30c6_0", { source: ".ps-container{position:relative}", map: undefined, media: undefined });

    };
    /* scoped */
    var __vue_scope_id__$4 = undefined;
    /* module identifier */
    var __vue_module_identifier__$4 = undefined;
    /* functional template */
    var __vue_is_functional_template__$4 = false;
    /* component normalizer */
    function __vue_normalize__$4(
      template, style, script,
      scope, functional, moduleIdentifier,
      createInjector, createInjectorSSR
    ) {
      var component = (typeof script === 'function' ? script.options : script) || {};

      // For security concerns, we use only base name in production mode.
      component.__file = "PerfectScrollbar.vue";

      if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) { component.functional = true; }
      }

      component._scopeId = scope;

      {
        var hook;
        if (style) {
          hook = function(context) {
            style.call(this, createInjector(context));
          };
        }

        if (hook !== undefined) {
          if (component.functional) {
            // register for functional component in vue file
            var originalRender = component.render;
            component.render = function renderWithStyleInjection(h, context) {
              hook.call(context);
              return originalRender(h, context)
            };
          } else {
            // inject component registration as beforeCreate hook
            var existing = component.beforeCreate;
            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
        }
      }

      return component
    }
    /* style inject */
    function __vue_create_injector__$1() {
      var head = document.head || document.getElementsByTagName('head')[0];
      var styles = __vue_create_injector__$1.styles || (__vue_create_injector__$1.styles = {});
      var isOldIE =
        typeof navigator !== 'undefined' &&
        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

      return function addStyle(id, css) {
        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

        var group = isOldIE ? css.media || 'default' : id;
        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

        if (!style.ids.includes(id)) {
          var code = css.source;
          var index = style.ids.length;

          style.ids.push(id);

          if (css.map) {
            // https://developer.chrome.com/devtools/docs/javascript-debugging
            // this makes source maps inside style tags work properly in Chrome
            code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
            // http://stackoverflow.com/a/26603875
            code +=
              '\n/*# sourceMappingURL=data:application/json;base64,' +
              btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
              ' */';
          }

          if (isOldIE) {
            style.element = style.element || document.querySelector('style[data-group=' + group + ']');
          }

          if (!style.element) {
            var el = style.element = document.createElement('style');
            el.type = 'text/css';

            if (css.media) { el.setAttribute('media', css.media); }
            if (isOldIE) {
              el.setAttribute('data-group', group);
              el.setAttribute('data-next-index', '0');
            }

            head.appendChild(el);
          }

          if (isOldIE) {
            index = parseInt(style.element.getAttribute('data-next-index'));
            style.element.setAttribute('data-next-index', index + 1);
          }

          if (style.element.styleSheet) {
            style.parts.push(code);
            style.element.styleSheet.cssText = style.parts
              .filter(Boolean)
              .join('\n');
          } else {
            var textNode = document.createTextNode(code);
            var nodes = style.element.childNodes;
            if (nodes[index]) { style.element.removeChild(nodes[index]); }
            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
            else { style.element.appendChild(textNode); }
          }
        }
      }
    }
    /* style inject SSR */
    

    
    var PerfectScrollbar$1 = __vue_normalize__$4(
      { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
      __vue_inject_styles__$4,
      __vue_script__$4,
      __vue_scope_id__$4,
      __vue_is_functional_template__$4,
      __vue_module_identifier__$4,
      __vue_create_injector__$1,
      undefined
    );

  var sidebarProps = {
    type: {
      type: String,
      default: 'light',
      validator: function (val) { return ['dark', 'light'].includes(val); }
    },
    variant: {
      type: String,
      default: null
    },
    align: {
      type: String,
      default: 'start',
      validator: function (val) { return ['start', 'end', 'left', 'right'].includes(val); }
    }
  };

  //

  var script$5 = {
    components: {
      PerfectScrollbar: PerfectScrollbar$1
    },
    props: sidebarProps,
    computed: {
      isRTL: function isRTL() {
        if (!process.server && this.$el) {
          return window.getComputedStyle(this.$el).direction === 'rtl'
        }
      },
      position: function position() {
        var position = this.align;
        var isRTL = this.isRTL;

        if (isRTL && ['left', 'right'].includes(position)) {
          if (position === 'left') {
            position = 'right';
          } else if (position === 'right') {
            position = 'left';
          }
        }

        if (this.align === 'start') {
          position = isRTL ? 'right' : 'left';
        }
        if (this.align === 'end') {
          position = isRTL ? 'left' : 'right';
        }

        return position
      },
      classes: function classes() {
        var classes = {};
        classes[("sidebar-" + (this.type))] = true;
        classes[("sidebar-" + (this.position))] = true;

        if (this.variant) {
          this.variant.split(' ').map(function (variant) { return (classes[variant] = true); });
        }

        return classes
      }
    }
  };

  /* script */
              var __vue_script__$5 = script$5;
              
  /* template */
  var __vue_render__$4 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('perfect-scrollbar',{staticClass:"sidebar o-hidden",class:_vm.classes},[_vm._t("default")],2)};
  var __vue_staticRenderFns__$4 = [];

    /* style */
    var __vue_inject_styles__$5 = undefined;
    /* scoped */
    var __vue_scope_id__$5 = undefined;
    /* module identifier */
    var __vue_module_identifier__$5 = undefined;
    /* functional template */
    var __vue_is_functional_template__$5 = false;
    /* component normalizer */
    function __vue_normalize__$5(
      template, style, script,
      scope, functional, moduleIdentifier,
      createInjector, createInjectorSSR
    ) {
      var component = (typeof script === 'function' ? script.options : script) || {};

      // For security concerns, we use only base name in production mode.
      component.__file = "Sidebar.vue";

      if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) { component.functional = true; }
      }

      component._scopeId = scope;

      return component
    }
    /* style inject */
    
    /* style inject SSR */
    

    
    var Sidebar = __vue_normalize__$5(
      { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
      __vue_inject_styles__$5,
      __vue_script__$5,
      __vue_scope_id__$5,
      __vue_is_functional_template__$5,
      __vue_module_identifier__$5,
      undefined,
      undefined
    );

  var prefixProps = function (props, prefix) {
    var newProps = {};
    Object.keys(props).forEach(function (prop) {
      newProps[(prefix + "-" + prop)] = props[prop];
    });

    return camelCaseKeys(newProps)
  };

  //

  var script$6 = {
    components: {
      Drawer: Drawer,
      Sidebar: Sidebar
    },
    extends: Settings,
    props: Object.assign({}, prefixProps(drawerProps, 'drawer'),
      prefixProps(sidebarProps, 'sidebar')),
    computed: {
      localAlign: function localAlign() {
        if (this.mainDrawerAlign) {
          return this.mainDrawerAlign === 'end' ? 'left' : 'right'
        }
        return this.drawerAlign
      },
      localSidebarVariant: function localSidebarVariant() {
        return this.sidebarVariant || 'sidebar-transparent-xs-up'
      }
    }
  };

  /* script */
              var __vue_script__$6 = script$6;
              
  /* template */
  var __vue_render__$5 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('drawer',{attrs:{"id":"settings","align":_vm.localAlign}},[_c('sidebar',{attrs:{"align":_vm.localAlign,"type":_vm.sidebarType,"variant":_vm.localSidebarVariant}},[_c('div',{staticClass:"p-2"},[_vm._l((_vm.options),function(option){return _c('collapse',{key:("collapse-" + (option.id)),attrs:{"id":option.id,"title":option.title}},_vm._l((option.children),function(group,index){return _c('b-form-group',{key:("group-" + (option.id) + "-" + index),class:{ 'mb-0': index === option.children.length - 1 },attrs:{"label":group.title}},[(group.component === 'form-image-group')?_c('form-image-group',{attrs:{"options":group.options,"name":group.id},model:{value:(_vm.settings[((option.id) + "." + (group.id))]),callback:function ($$v) {_vm.$set(_vm.settings, ((option.id) + "." + (group.id)), $$v);},expression:"settings[`${option.id}.${group.id}`]"}}):_vm._e(),_vm._v(" "),(group.component === 'b-form-radio-group')?_c('b-form-radio-group',{attrs:{"id":("group-" + (option.id) + "-" + index),"options":group.options},model:{value:(_vm.settings[((option.id) + "." + (group.id))]),callback:function ($$v) {_vm.$set(_vm.settings, ((option.id) + "." + (group.id)), $$v);},expression:"settings[`${option.id}.${group.id}`]"}}):_vm._e(),_vm._v(" "),(group.component === 'b-form-checkbox')?_c('b-form-checkbox',{attrs:{"id":("group-" + (option.id) + "-" + index)},model:{value:(_vm.settings[((option.id) + "." + (group.id))]),callback:function ($$v) {_vm.$set(_vm.settings, ((option.id) + "." + (group.id)), $$v);},expression:"settings[`${option.id}.${group.id}`]"}},[_vm._v("\n            "+_vm._s(group.title)+"\n          ")]):_vm._e(),_vm._v(" "),(group.component === 'custom-checkbox-toggle')?_c('b-form-checkbox',{staticClass:"custom-checkbox-toggle custom-control-inline mr-1",attrs:{"id":("group-" + (option.id) + "-" + index)},model:{value:(_vm.settings[((option.id) + "." + (group.id))]),callback:function ($$v) {_vm.$set(_vm.settings, ((option.id) + "." + (group.id)), $$v);},expression:"settings[`${option.id}.${group.id}`]"}},[_vm._v("Â ")]):_vm._e(),_vm._v(" "),(group.component === 'custom-checkbox-toggle')?_c('label',{staticClass:"mb-0",attrs:{"for":("group-" + (option.id) + "-" + index)}},[_c('span',{staticClass:"form-label m-0"},[_vm._v(_vm._s(group.title))])]):_vm._e()],1)}),1)}),_vm._v(" "),_vm._t("default"),_vm._v(" "),(_vm.debug)?_c('pre',{domProps:{"textContent":_vm._s(_vm.settings)}}):_vm._e()],2)])],1)};
  var __vue_staticRenderFns__$5 = [];

    /* style */
    var __vue_inject_styles__$6 = function (inject) {
      if (!inject) { return }
      inject("data-v-479fc8fe_0", { source: "#settings .mdk-drawer__content{width:300px}#settings .mdk-drawer__scrim{background-color:rgba(56,59,61,.5)}#settings .col-form-label{font-size:.75rem;text-transform:uppercase;color:#b8bdc2;line-height:1rem;font-weight:500}", map: undefined, media: undefined });

    };
    /* scoped */
    var __vue_scope_id__$6 = undefined;
    /* module identifier */
    var __vue_module_identifier__$6 = undefined;
    /* functional template */
    var __vue_is_functional_template__$6 = false;
    /* component normalizer */
    function __vue_normalize__$6(
      template, style, script,
      scope, functional, moduleIdentifier,
      createInjector, createInjectorSSR
    ) {
      var component = (typeof script === 'function' ? script.options : script) || {};

      // For security concerns, we use only base name in production mode.
      component.__file = "Drawer.vue";

      if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) { component.functional = true; }
      }

      component._scopeId = scope;

      {
        var hook;
        if (style) {
          hook = function(context) {
            style.call(this, createInjector(context));
          };
        }

        if (hook !== undefined) {
          if (component.functional) {
            // register for functional component in vue file
            var originalRender = component.render;
            component.render = function renderWithStyleInjection(h, context) {
              hook.call(context);
              return originalRender(h, context)
            };
          } else {
            // inject component registration as beforeCreate hook
            var existing = component.beforeCreate;
            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
        }
      }

      return component
    }
    /* style inject */
    function __vue_create_injector__$2() {
      var head = document.head || document.getElementsByTagName('head')[0];
      var styles = __vue_create_injector__$2.styles || (__vue_create_injector__$2.styles = {});
      var isOldIE =
        typeof navigator !== 'undefined' &&
        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

      return function addStyle(id, css) {
        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

        var group = isOldIE ? css.media || 'default' : id;
        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

        if (!style.ids.includes(id)) {
          var code = css.source;
          var index = style.ids.length;

          style.ids.push(id);

          if (css.map) {
            // https://developer.chrome.com/devtools/docs/javascript-debugging
            // this makes source maps inside style tags work properly in Chrome
            code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
            // http://stackoverflow.com/a/26603875
            code +=
              '\n/*# sourceMappingURL=data:application/json;base64,' +
              btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
              ' */';
          }

          if (isOldIE) {
            style.element = style.element || document.querySelector('style[data-group=' + group + ']');
          }

          if (!style.element) {
            var el = style.element = document.createElement('style');
            el.type = 'text/css';

            if (css.media) { el.setAttribute('media', css.media); }
            if (isOldIE) {
              el.setAttribute('data-group', group);
              el.setAttribute('data-next-index', '0');
            }

            head.appendChild(el);
          }

          if (isOldIE) {
            index = parseInt(style.element.getAttribute('data-next-index'));
            style.element.setAttribute('data-next-index', index + 1);
          }

          if (style.element.styleSheet) {
            style.parts.push(code);
            style.element.styleSheet.cssText = style.parts
              .filter(Boolean)
              .join('\n');
          } else {
            var textNode = document.createTextNode(code);
            var nodes = style.element.childNodes;
            if (nodes[index]) { style.element.removeChild(nodes[index]); }
            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
            else { style.element.appendChild(textNode); }
          }
        }
      }
    }
    /* style inject SSR */
    

    
    var Drawer$1 = __vue_normalize__$6(
      { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
      __vue_inject_styles__$6,
      __vue_script__$6,
      __vue_scope_id__$6,
      __vue_is_functional_template__$6,
      __vue_module_identifier__$6,
      __vue_create_injector__$2,
      undefined
    );

  /* script */

  /* template */
  var __vue_render__$6 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('i',{staticClass:"material-icons"},[_vm._t("default",[_vm._v("credit_card")])],2)};
  var __vue_staticRenderFns__$6 = [];

    /* style */
    var __vue_inject_styles__$7 = undefined;
    /* scoped */
    var __vue_scope_id__$7 = undefined;
    /* module identifier */
    var __vue_module_identifier__$7 = undefined;
    /* functional template */
    var __vue_is_functional_template__$7 = false;
    /* component normalizer */
    function __vue_normalize__$7(
      template, style, script,
      scope, functional, moduleIdentifier,
      createInjector, createInjectorSSR
    ) {
      var component = (typeof script === 'function' ? script.options : script) || {};

      // For security concerns, we use only base name in production mode.
      component.__file = "MdIcon.vue";

      if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) { component.functional = true; }
      }

      component._scopeId = scope;

      return component
    }
    /* style inject */
    
    /* style inject SSR */
    

    
    var MdIcon = __vue_normalize__$7(
      { render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 },
      __vue_inject_styles__$7,
      {},
      __vue_scope_id__$7,
      __vue_is_functional_template__$7,
      __vue_module_identifier__$7,
      undefined,
      undefined
    );

  //
  var script$7 = {
    components: {
      MdIcon: MdIcon
    },
    props: {
      align: {
        type: String,
        default: 'right'
      }
    },
    computed: {
      localAlign: function localAlign() {
        if (this.mainDrawerAlign) {
          return this.mainDrawerAlign === 'end' ? 'left' : 'right'
        }
        return this.align
      },
      buttonClass: function buttonClass() {
        return ['app-settings-button', ("app-settings-button--" + (this.localAlign))]
      }
    }
  };

  /* script */
              var __vue_script__$7 = script$7;
              
  /* template */
  var __vue_render__$7 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('b-btn',{directives:[{name:"f-toggle",rawName:"v-f-toggle.settings",modifiers:{"settings":true}}],class:_vm.buttonClass,attrs:{"variant":"dark"}},[_c('md-icon',[_vm._v("settings")])],1)};
  var __vue_staticRenderFns__$7 = [];

    /* style */
    var __vue_inject_styles__$8 = function (inject) {
      if (!inject) { return }
      inject("data-v-a8bfd972_0", { source: ".app-settings-button[data-v-a8bfd972]{position:fixed;top:100px}.app-settings-button--right[data-v-a8bfd972]{right:0;border-top-right-radius:0;border-bottom-right-radius:0}.app-settings-button--left[data-v-a8bfd972]{left:0;border-top-left-radius:0;border-bottom-left-radius:0}", map: undefined, media: undefined });

    };
    /* scoped */
    var __vue_scope_id__$8 = "data-v-a8bfd972";
    /* module identifier */
    var __vue_module_identifier__$8 = undefined;
    /* functional template */
    var __vue_is_functional_template__$8 = false;
    /* component normalizer */
    function __vue_normalize__$8(
      template, style, script,
      scope, functional, moduleIdentifier,
      createInjector, createInjectorSSR
    ) {
      var component = (typeof script === 'function' ? script.options : script) || {};

      // For security concerns, we use only base name in production mode.
      component.__file = "Button.vue";

      if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) { component.functional = true; }
      }

      component._scopeId = scope;

      {
        var hook;
        if (style) {
          hook = function(context) {
            style.call(this, createInjector(context));
          };
        }

        if (hook !== undefined) {
          if (component.functional) {
            // register for functional component in vue file
            var originalRender = component.render;
            component.render = function renderWithStyleInjection(h, context) {
              hook.call(context);
              return originalRender(h, context)
            };
          } else {
            // inject component registration as beforeCreate hook
            var existing = component.beforeCreate;
            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
        }
      }

      return component
    }
    /* style inject */
    function __vue_create_injector__$3() {
      var head = document.head || document.getElementsByTagName('head')[0];
      var styles = __vue_create_injector__$3.styles || (__vue_create_injector__$3.styles = {});
      var isOldIE =
        typeof navigator !== 'undefined' &&
        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

      return function addStyle(id, css) {
        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

        var group = isOldIE ? css.media || 'default' : id;
        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

        if (!style.ids.includes(id)) {
          var code = css.source;
          var index = style.ids.length;

          style.ids.push(id);

          if (css.map) {
            // https://developer.chrome.com/devtools/docs/javascript-debugging
            // this makes source maps inside style tags work properly in Chrome
            code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
            // http://stackoverflow.com/a/26603875
            code +=
              '\n/*# sourceMappingURL=data:application/json;base64,' +
              btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
              ' */';
          }

          if (isOldIE) {
            style.element = style.element || document.querySelector('style[data-group=' + group + ']');
          }

          if (!style.element) {
            var el = style.element = document.createElement('style');
            el.type = 'text/css';

            if (css.media) { el.setAttribute('media', css.media); }
            if (isOldIE) {
              el.setAttribute('data-group', group);
              el.setAttribute('data-next-index', '0');
            }

            head.appendChild(el);
          }

          if (isOldIE) {
            index = parseInt(style.element.getAttribute('data-next-index'));
            style.element.setAttribute('data-next-index', index + 1);
          }

          if (style.element.styleSheet) {
            style.parts.push(code);
            style.element.styleSheet.cssText = style.parts
              .filter(Boolean)
              .join('\n');
          } else {
            var textNode = document.createTextNode(code);
            var nodes = style.element.childNodes;
            if (nodes[index]) { style.element.removeChild(nodes[index]); }
            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
            else { style.element.appendChild(textNode); }
          }
        }
      }
    }
    /* style inject SSR */
    

    
    var Button = __vue_normalize__$8(
      { render: __vue_render__$7, staticRenderFns: __vue_staticRenderFns__$7 },
      __vue_inject_styles__$8,
      __vue_script__$7,
      __vue_scope_id__$8,
      __vue_is_functional_template__$8,
      __vue_module_identifier__$8,
      __vue_create_injector__$3,
      undefined
    );

  // Are we client side?
  var inBrowser = typeof window !== 'undefined';

  // target listen types
  var listenTypes = { click: true };

  // Property key for handler storage
  var BVT = '__BV_toggle__';

  // Emitted Control Event for collapse (emitted to collapse)
  var EVENT_TOGGLE$1 = 'fm::toggle::drawer';

  // Listen to Event for toggle state update (Emited by collapse)
  var EVENT_STATE$1 = 'fm::drawer::state';

  var toggle = {
    bind: function bind(el, binding, vnode) {
      var targets = target(
        vnode,
        binding,
        listenTypes,
        function (ref) {
          var targets = ref.targets;
          var vnode = ref.vnode;

          targets.forEach(function (target$$1) {
            vnode.context.$root.$emit(EVENT_TOGGLE$1, target$$1);
          });
        }
      );

      if (inBrowser && vnode.context && targets.length > 0) {
        // Add aria attributes to element
        dom.setAttr(el, 'aria-controls', targets.join(' '));
        dom.setAttr(el, 'aria-expanded', 'false');
        if (el.tagName !== 'BUTTON') {
          // If element is not a button, we add `role="button"` for accessibility
          dom.setAttr(el, 'role', 'button');
        }

        // Toggle state hadnler, stored on element
        el[BVT] = function toggleDirectiveHandler(id, state) {
          if (targets.indexOf(id) !== -1) {
            // Set aria-expanded state
            dom.setAttr(el, 'aria-expanded', state.show ? 'true' : 'false');
            // Set/Clear 'active' class state
            if (state.show) {
              dom.addClass(el, 'active');
            } else {
              dom.removeClass(el, 'active');
            }
          }
        };

        // Listen for toggle state changes
        vnode.context.$root.$on(EVENT_STATE$1, el[BVT]);
      }
    },
    unbind: function unbind(el, binding, vnode) {
      if (el[BVT]) {
        // Remove our $root listener
        vnode.context.$root.$off(EVENT_STATE$1, el[BVT]);
        el[BVT] = null;
      }
    }
  };

  exports.FmAppSettingsBase = Settings;
  exports.FmAppSettingsDrawer = Drawer$1;
  exports.FmAppSettingsButton = Button;
  exports.FmAppSettingsCollapse = Collapse;
  exports.FmToggleDirective = toggle;
  exports.Session = Session;
  exports.listenOnRootMixin = listenOnRootMixin;
  exports.sidebarProps = sidebarProps;
  exports.prefixProps = prefixProps;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
